/**
 * AI Attribution Module for GitHub Comments
 * Provides clear attribution for AI-generated content
 */

class AIAttribution {
    constructor() {
        this.agentTypes = {
            CLAUDE: {
                name: 'Claude',
                emoji: 'ü§ñ',
                signature: 'Claude AI Assistant',
                provider: 'Anthropic'
            },
            RUV_SWARM: {
                name: 'ruv-swarm',
                emoji: 'üêù',
                signature: 'ruv-swarm Agent',
                provider: 'Swarm Intelligence'
            },
            SWARM_RESEARCHER: {
                name: 'Researcher',
                emoji: 'üî¨',
                signature: 'Research Agent',
                provider: 'ruv-swarm'
            },
            SWARM_CODER: {
                name: 'Coder',
                emoji: 'üíª',
                signature: 'Coding Agent',
                provider: 'ruv-swarm'
            },
            SWARM_ANALYST: {
                name: 'Analyst',
                emoji: 'üìä',
                signature: 'Analysis Agent',
                provider: 'ruv-swarm'
            },
            SWARM_COORDINATOR: {
                name: 'Coordinator',
                emoji: 'üéØ',
                signature: 'Coordination Agent',
                provider: 'ruv-swarm'
            },
            AUTOMATION: {
                name: 'Automation',
                emoji: '‚öôÔ∏è',
                signature: 'GitHub Automation',
                provider: 'System'
            }
        };
    }

    /**
     * Wrap content with AI attribution header and footer
     * @param {string} content - The original comment content
     * @param {string} agentType - Type of AI agent (from agentTypes)
     * @param {Object} metadata - Additional metadata (optional)
     * @returns {string} - Formatted comment with attribution
     */
    wrapWithAttribution(content, agentType = 'CLAUDE', metadata = {}) {
        const agent = this.agentTypes[agentType] || this.agentTypes.CLAUDE;
        const timestamp = new Date().toISOString();
        
        // Build header
        const header = this.buildHeader(agent, metadata);
        
        // Build footer
        const footer = this.buildFooter(agent, timestamp, metadata);
        
        // Combine everything
        return `${header}\n\n${content}\n\n${footer}`;
    }

    /**
     * Build the attribution header
     */
    buildHeader(agent, metadata) {
        const lines = [
            `${agent.emoji} **${agent.signature}**`,
            ``,
            `---`,
            `*This comment was generated by ${agent.name} (${agent.provider})*`
        ];

        if (metadata.taskId) {
            lines.push(`*Task ID: ${metadata.taskId}*`);
        }

        if (metadata.sessionId) {
            lines.push(`*Session: ${metadata.sessionId}*`);
        }

        lines.push('---');
        
        return lines.join('\n');
    }

    /**
     * Build the attribution footer
     */
    buildFooter(agent, timestamp, metadata) {
        const lines = ['---'];
        
        // Add metadata tags
        const tags = [`ai-generated`, `by-${agent.name.toLowerCase()}`];
        
        if (metadata.phase) {
            tags.push(`phase-${metadata.phase}`);
        }
        
        if (metadata.automated) {
            tags.push('automated');
        }
        
        lines.push(`\`\`\`\n${tags.join(' ')}\n\`\`\``);
        
        // Add timestamp and signature
        lines.push(`*Generated at: ${timestamp}*`);
        lines.push(`*${agent.emoji} ${agent.signature} | Powered by ${agent.provider}*`);
        
        return lines.join('\n');
    }

    /**
     * Create a standardized AI progress update
     */
    createProgressUpdate(progress, agentType = 'CLAUDE') {
        const content = [
            `**Progress Update**`,
            ``,
            `Status: ${progress.status}`,
            `Phase: ${progress.phase}`,
            `Completion: ${progress.percentage}%`,
            ``
        ];

        if (progress.currentTask) {
            content.push(`Current Task: ${progress.currentTask}`);
            content.push(``);
        }

        if (progress.updates && progress.updates.length > 0) {
            content.push(`**Recent Activities:**`);
            progress.updates.forEach(update => {
                content.push(`- ${update}`);
            });
        }

        return this.wrapWithAttribution(
            content.join('\n'),
            agentType,
            {
                phase: progress.phase,
                automated: true
            }
        );
    }

    /**
     * Create a standardized error message
     */
    createErrorMessage(error, context, agentType = 'AUTOMATION') {
        const content = [
            `‚ùå **Error Encountered**`,
            ``,
            `**Context:** ${context}`,
            `**Error:** ${error.message || error}`,
            ``,
            `This issue requires human attention.`
        ];

        if (error.stack) {
            content.push(``, `<details>`, `<summary>Error Details</summary>`, ``, `\`\`\``, error.stack, `\`\`\``, `</details>`);
        }

        return this.wrapWithAttribution(
            content.join('\n'),
            agentType,
            {
                automated: true,
                error: true
            }
        );
    }

    /**
     * Check if a comment is AI-generated based on its content
     */
    isAIGenerated(commentBody) {
        // Check for AI attribution markers
        const markers = [
            'ai-generated',
            'This comment was generated by',
            'AI Assistant',
            'ruv-swarm',
            'Generated at:',
            'Powered by'
        ];

        return markers.some(marker => commentBody.includes(marker));
    }

    /**
     * Extract agent type from comment body
     */
    extractAgentType(commentBody) {
        for (const [key, agent] of Object.entries(this.agentTypes)) {
            if (commentBody.includes(agent.signature) || 
                commentBody.includes(`by-${agent.name.toLowerCase()}`)) {
                return key;
            }
        }
        return null;
    }

    /**
     * Create a simple attribution line for inline use
     */
    getInlineAttribution(agentType = 'CLAUDE') {
        const agent = this.agentTypes[agentType] || this.agentTypes.CLAUDE;
        return `${agent.emoji} *${agent.signature}*`;
    }
}

module.exports = AIAttribution;